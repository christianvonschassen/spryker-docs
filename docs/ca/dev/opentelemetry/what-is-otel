---
title: What is OpenTelemetry
description: Describing what is OpenTelemetry.
template: howto-guide-template
last_updated: Feb 1, 2025
related:
---

Spryker allows to integrate different monitoring tools like NewRelic into the SCCOS. But usually those tools are vendor locked and allows to work only with limited amount of backends or have not so much customizability options.
In order to give you more customisable options, Spryker introduces an OpenTelemetry integration that allows to make your monitoring system more custom tailored based on your requirements and in the same time uses open standards that are widely accepted in community.

## Overview

You may want to get familiar with [OpenTelemetry Documentation first](https://opentelemetry.io/docs/concepts/signals/traces/), but we are going to give you a brief overview here too.

### Things that you should know

#### Trace
Trace represents a single transaction. It has a unique ID and all spans are related to it. Trace has a name that is defined automatically or can be changed with `\Spryker\Service\Monitoring\MonitoringServiceInterface::setTransactionName()` method if you wire a plugin for it. E.g. it can be a route name.

#### Span
A span represents a unit of work or operation. Spans are the building blocks of Traces. In OpenTelemetry, they include the following information:
- Name
- Parent span ID (empty for root spans)
- Start and End Timestamps
- Span Context
- Attributes
- Span Events
- Span Links
- Span Status

You can say that Span in our case represents an execution of a single method.

#### Hook
OpenTelemetry provides a way to instrument your code without modifying it directly. Hook is a function that executes a closure before and after method execution.
So when you execute your method `pre` closure is executing and should open a span. And after the method execution is done, `post` closure is execution and should catch if method was executed successfully, add missing attributes (you can add a method return value, but we would not recommend it) and close a span.

Example of a hook you can see below. All hooks that are autogenerated or provided by some library (e.g. Spryker provides hook for Propel, Redis, RabbitMq, Guzzle and ElasticSearch classes) will be registered automatically. If you want to register your own hook for some class, make sure that registration is executed before the method you want to instrument is called.
```php
<?php
\OpenTelemetry\Instrumentation\hook(
                class: MyClass::class, //Class that we want to instrument
                function: 'methodName', //Method of this class. It can be even a private method.
                pre: static function (
                $instance, //Instance of the MyClass
                array $params, //Incoming method parameters.
                string $class, //Class name as a string
                string $function, //Method name
                ?string $filename, //Actual file name that is executed
                ?int $lineno //Number of the line where this method is triggered
                ) {
                    //Context is used to keep all spans connected. In this case we can say that context represents a parent span (node).
                    $context = \OpenTelemetry\Context\Context::getCurrent();

                    $span = \Spryker\Shared\OpenTelemetry\Instrumentation\CachedInstrumentation::getCachedInstrumentation()
                        ->tracer()
                        ->spanBuilder('ModuleName-MyClass::methodName')//Span name can be not unique, but it would easier to make it such if you want to find it easily.
                        ->setParent($context)//Here we define that this span should be attached to a parent one
                        ->setAttribute(\OpenTelemetry\SemConv\TraceAttributes::CODE_FUNCTION, $function)//You can attach almost everything as a param as long as the value is scalar. Null value means that attribute will be omitted.
                        ->setAttribute(\OpenTelemetry\SemConv\TraceAttributes::CODE_NAMESPACE, $class)
                        ->setAttribute(\OpenTelemetry\SemConv\TraceAttributes::CODE_FILEPATH, $filename)
                        ->setAttribute(\OpenTelemetry\SemConv\TraceAttributes::CODE_LINENO, $lineno)
                        ->startSpan();

                    //Here we attach a span to the global context in order to build a tree.
                    \OpenTelemetry\Context\Context::storage()->attach($span->storeInContext($context));
                },

                post: static function (
                $instance,
                array $params,
                $returnValue, //Result of the method execution.
                ?\Throwable $exception //Exception if one was thrown during the execution
                ) {
                    $scope = \OpenTelemetry\Context\Context::storage()->scope();

                    if (null === $scope) {
                        return;
                    }

                    //Here you can just check the $exception value. But in some cases you might want to take if from other places. E.g. if method that thrown exception was not instrumented, we still want to catch it in a parent span.
                    $error = error_get_last();

                    if (is_array($error) && in_array($error['type'], [E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE], true)) {
                        $exception = new \Exception(
                            'Error: ' . $error['message'] . ' in ' . $error['file'] . ' on line ' . $error['line']
                        );
                    }

                    $scope->detach();
                    $span = \Spryker\Service\Opentelemetry\Instrumentation\Span\Span::fromContext($scope->context());

                    if ($exception !== null) {
                        $span->recordException($exception);//Exception will be attached as an event into the span.
                        $span->setAttribute('error_message', $exception->getMessage());
                        $span->setAttribute('error_code', $exception->getCode());
                    }

                    //Status code adds some visibility. Error status code will mark your span as a one with an error for easier navigation.
                    $span->setStatus($exception !== null ? \OpenTelemetry\API\Trace\StatusCode::STATUS_ERROR : \OpenTelemetry\API\Trace\StatusCode::STATUS_OK);

                    //Span ends and sent into a span processor to be validated and prepared for exporting.
                    $span->end();
                }
            );
```

### Collector
Collector collects traces and sends them to your monitoring platform afterwards. Sending traces to collector is done after that request is sent, so it will not impact response time. Collector itself is not a part of an application and should be prepared by a Cloud engineer (or you can add one for you local setup by yourself).