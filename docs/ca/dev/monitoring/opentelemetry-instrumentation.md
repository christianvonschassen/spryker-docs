---
title: OpenTelemetry instrumentation
description: Describing what is OpenTelemetry and how Spryker integrates it in the SCCOS
template: howto-guide-template
last_updated: Feb 1, 2025
---

This document describes how to configure and instrument application for OpenTelemetry (OTel). It contains a brief overview of basic OTel concepts, but reading [OpenTelemetry documentation](https://opentelemetry.io/docs/concepts/) first is recommended.


## Convention
The current implementation follows [OpenTelemetry Semantic Conventions 1.30.0](https://opentelemetry.io/docs/specs/semconv/).

## Trace
A trace represents a single transaction. It has a unique ID and all spans are related to it. Each trace has a name that is defined automatically or can be changed as described in [Integration](#integration).

## Span

A span represents a unit of work or operation, similar to executing a single method. As the building blocks of traces, spans contain the following information:

- Name
- Parent span ID (empty for root spans)
- Start and End Timestamps
- Span Context
- Attributes
- Span Events
- Span Links
- Span Status



## Hook

A hook is a function that executes a closure before and after method execution, providing a way to instrument code without modifying it directly.
When you execute a method, a `pre` closure is executed and opens a span. After the method is executed, a `post` closure is executed and caught. Then, missing attributes are added and the span is closed.

All hooks that are autogenerated or provided by a library, such as Propel or Redis hooks provided by Spryker, are registered automatically.

If you want to register a hook for a class, make sure the registration is executed before the method you want to instrument is called.

<details>
  <summary>Hook example</summary>

```php
<?php
\OpenTelemetry\Instrumentation\hook(
                class: MyClass::class, //Class name that should be instrumented.
                function: 'methodName', //Method of this class. It can be even a private method.
                pre: static function (
                $instance, //Instance of the MyClass
                array $params, //Incoming method parameters.
                string $class, //Class name as a string
                string $function, //Method name
                ?string $filename, //Actual file name that is executed
                ?int $lineno //Number of the line where this method is triggered
                ) {
                    //Context is used to keep all spans connected. In this case this is a parent span.
                    $context = \OpenTelemetry\Context\Context::getCurrent();

                    $span = \Spryker\Shared\OpenTelemetry\Instrumentation\CachedInstrumentation::getCachedInstrumentation()
                        ->tracer()
                        ->spanBuilder('ModuleName-MyClass::methodName')//Span name can be not unique, but it would easier to make it such if you want to find it easily.
                        ->setParent($context)//Here parent span is attached to the current span.
                        ->setAttribute(\OpenTelemetry\SemConv\TraceAttributes::CODE_FUNCTION, $function)//You can attach almost everything as a param as long as the value is scalar. Null value means that attribute will be omitted.
                        ->setAttribute(\OpenTelemetry\SemConv\TraceAttributes::CODE_NAMESPACE, $class)
                        ->setAttribute(\OpenTelemetry\SemConv\TraceAttributes::CODE_FILEPATH, $filename)
                        ->setAttribute(\OpenTelemetry\SemConv\TraceAttributes::CODE_LINENO, $lineno)
                        ->startSpan();

                    //Here span is attached to the global context
                    \OpenTelemetry\Context\Context::storage()->attach($span->storeInContext($context));
                },

                post: static function (
                $instance,
                array $params,
                $returnValue, //Result of the method execution.
                ?\Throwable $exception //Exception if one was thrown during the execution
                ) {
                    $scope = \OpenTelemetry\Context\Context::storage()->scope();

                    if (null === $scope) {
                        return;
                    }

                    //Here you can just check the $exception value. But in some cases you might want to take if from other places. E.g. if method that thrown exception was not instrumented, parent span should still have it.
                    $error = error_get_last();

                    if (is_array($error) && in_array($error['type'], [E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE], true)) {
                        $exception = new \Exception(
                            'Error: ' . $error['message'] . ' in ' . $error['file'] . ' on line ' . $error['line']
                        );
                    }

                    $scope->detach();
                    $span = \Spryker\Service\Opentelemetry\Instrumentation\Span\Span::fromContext($scope->context());

                    if ($exception !== null) {
                        $span->recordException($exception);//Exception will be attached as an event into the span.
                        $span->setAttribute('error_message', $exception->getMessage());
                        $span->setAttribute('error_code', $exception->getCode());
                    }

                    //Status code adds some visibility. Error status code will mark your span as a one with an error for easier navigation.
                    $span->setStatus($exception !== null ? \OpenTelemetry\API\Trace\StatusCode::STATUS_ERROR : \OpenTelemetry\API\Trace\StatusCode::STATUS_OK);

                    //Span ends and sent into a span processor to be validated and prepared for exporting.
                    $span->end();
                }
            );
```

</details>

## Collector
Collector collects traces and sends them to a monitoring platform. Traces are sent to collector after that request is sent so it doesn't affect response time. Collector operates separately from the application and should be set up by a Cloud engineer or you can add one for you local setup yourself.

## Integration

Run the latest version of the script from the [Installer repo](https://github.com/spryker/opentelemetry-installer/).

If you want to integrate manually, the following sections describe all steps of the scripts.

### Install required packages

OTel provides instrumentation via packages that can be installed to register hooks automatically. If you want to instrument additional parts of an application, such as Symfony code, you can install respective packages from [Registry](https://opentelemetry.io/ecosystem/registry/?language=php) or other sources.

{% info_block warningBox %}
Install third-party packages at your own risk.
{% endinfo_block %}


The [spryker/opentelemetry](https://packagist.org/packages/spryker/opentelemetry) package covers the essential parts of the integration:
* The entry point for instrumentation
* Plugin to wire in your monitoring service
* A console command to generate [hooks](https://opentelemetry.io/docs/zero-code/php/#how-it-works) for project's code, which creates spans automatically
* Instrumentation of Propel, Redis, ElasticSearch, RabbitMQ, and Guzzle calls

### Optional: Install the Monitoring module

The Monitoring module enables you to add custom attributes and events, change trace names during the request execution, and add exceptions to the root span for visibility.

You can get the Monitoring module from the [Packagist](https://packagist.org/packages/spryker/monitoring).

Install the module and wire the Monitoring plugin.

```php
<?php

namespace Pyz\Service\Monitoring;

use Spryker\Service\Monitoring\MonitoringDependencyProvider as SprykerMonitoringDependencyProvider;
use Spryker\Service\Opentelemetry\Plugin\OpentelemetryMonitoringExtensionPlugin;

class MonitoringDependencyProvider extends SprykerMonitoringDependencyProvider
{
    /**
     * @return array<\Spryker\Service\MonitoringExtension\Dependency\Plugin\MonitoringExtensionPluginInterface>
     */
    protected function getMonitoringExtensions(): array
    {
        return [
            new OpentelemetryMonitoringExtensionPlugin(),
        ];
    }
}

```


You can call methods from Monitoring service, and they will be translated to OTel actions. Some methods act as placeholders because they're are not implemented in OTel, like `\Spryker\Service\Opentelemetry\Plugin\OpentelemetryMonitoringExtensionPlugin::markStartTransaction()` as transaction will start anyway.



### Wire a console command

Spryker is a large application, so manually creating all hooks is impractical. The `OpentelemetryGeneratorConsole` command automates hook generation for classes you want to cover with spans.

```php
<?php

namespace Pyz\Zed\Console;

...
use Spryker\Zed\Opentelemetry\Communication\Plugin\Console\OpentelemetryGeneratorConsole;
...

class ConsoleDependencyProvider extends SprykerConsoleDependencyProvider
{
    protected function getConsoleCommands(Container $container): array
    {
        $commands = [
            ...
            new OpentelemetryGeneratorConsole(),
            ...
        ];

        return $commands;
    }
}

```

Wire this console command into your install script to run on every deployment during the base container image build. Place it last in the `build` section, ensuring it runs after all code modifications and generation.

```yaml
sections:
    build:
        generate-open-telemetry:
            command: 'vendor/bin/console open-telemetry:generate'
```

### Configure hooks generation

You can control instrumentation by configuring specific methods.

Use `\Spryker\Zed\Opentelemetry\OpentelemetryConfig::getExcludedDirs()` to exclude directories from instrumentation. For example, you don't need spans from infrastructure code in traces. Several directories are excluded by default, review them in the module's vendor directory if you need to include any.  

Example of the method:

```php
class OpentelemetryConfig extends AbstractBundleConfig
{
    // Traces for Monitoring module, OTel module and tests in existing module are not relevant for the monitoring, so those will be excluded. In the actual implementation you can see more directories.
    public function getExcludedDirs(): array
    {
        return [
        ...
            'Monitoring',
            'OpenTelemetry',
            'tests',
        ...
        ];
    }
}
```

Use `\Spryker\Zed\Opentelemetry\OpentelemetryConfig::getExcludedSpans()` to exclude spans by name. This may be useful when spans you want to include and those you want to keep are in the same directory..

```php
class OpentelemetryConfig extends AbstractBundleConfig
{
    // In this example a span with a 'User-UserFacade::isSystemUser' name will be not generated as it's not relevant for our traces, but in the same time it's called a lot of times during the request
    public function getExcludedSpans(): array
    {
        return [
            ...
            'User-UserFacade::isSystemUser',
            ...
        ];
    }

}
```

`\Spryker\Zed\Opentelemetry\OpentelemetryConfig::getPathPatterns()` defines the path patterns where the console command should search for classes to instrument with hooks.

By default, all Spryker directories and the `Pyz` namespace are covered at the project level. However, avoid instrumenting autogenerated code, such as Transfers, to prevent unnecessary spans.

Implementation example:

```php
class OpentelemetryConfig extends AbstractBundleConfig
{
    public function getPathPatterns(): array
    {
        return [
            '#^vendor/spryker/[^/]+/.*/.*/(Zed|Shared)/.*/(?!Persistence|Presentation)[^/]+/.*#',
            '#^vendor/spryker/[^/]+/Glue.*#',
            '#^vendor/spryker(?:/spryker)?-shop/[^/]+/.*#',
            '#^vendor/spryker-eco/[^/]+/.*#',
            '#^src/Pyz/.*#',
        ];
    }

}
```

`\Spryker\Zed\Opentelemetry\OpentelemetryConfig::getOutputDir()` - specifies in what directory you want to put generated hooks. Default value is `src/Generated/OpenTelemetry/Hooks/`. The classmap file will also be added into this directory with the name `classmap.php`.

`\Spryker\Zed\Opentelemetry\OpentelemetryConfig::getOutputDir()` specifies the directory where generated hooks are stored. By default, they are placed in `src/Generated/OpenTelemetry/Hooks/`. The `classmap.php` file, which maps generated classes, is also added to this directory.


```php
class OpentelemetryConfig extends AbstractBundleConfig
{
    public function getOutputDir(): string
    {
        return APPLICATION_SOURCE_DIR . '/Generated/OpenTelemetry/Hooks/';
    }

}
```

`\Spryker\Zed\Opentelemetry\OpentelemetryConfig::areOnlyPublicMethodsInstrumented()` - OOTB hooks are generated only for public methods of regular classes and all methods of Controller classes, but you can change that with this configuration method.
```php
class OpentelemetryConfig extends AbstractBundleConfig
{
    public function areOnlyPublicMethodsInstrumented(): bool
    {
        return true;
    }

}
```

`\Spryker\Zed\Opentelemetry\OpentelemetryConfig::getCriticalClassNamePatterns()` - some of the spans can be marked as `critical` in order to give them more priority on sampling. You can define what classes you are interested in for that. OOTB Controllers and Facades are included. With the current implementation it's not a Regex, but just a part of the class name.
```php
class OpentelemetryConfig extends AbstractBundleConfig
{
    public function getCriticalClassNamePatterns(): array
    {
        return [
            'Facade',
            'Controller',
        ];
    }

}
```

### Enable PHP extensions

Hooks processing requires you to have a few PHP extensions in place. Spryker has prepared a new PHP image, so you need to install nothing, just enable them in your deploy file.

```yaml
namespace: spryker-otel
tag: 'dev'

environment: docker.dev
image:
    tag: spryker/php:8.3-alpine3.20-otel
    php:
        enabled-extensions:
            - opentelemetry
            - grpc
            - protobuf
```
Be advised that according to [extension README](https://github.com/open-telemetry/opentelemetry-php-instrumentation?tab=readme-ov-file#conflicting-extensions) `blackfire` extension can have a conflict with a `opentelemetry` extension, so make sure that you are not using both in the same time. The `newrelic` extension also has conflict in Distributed Tracing headers mechanism, so using both extensions in the same time will cause broken traces in your APM.


## Sampling

Spryker is a big application with humongous amount of methods executed during the request. Some of them executed a lot of times. OTel uses a PHP functions to open and close spans. This can add not desired load on your application, so instruments to reduce amount of spans that is sent with traces are in place.

In our implementation sampling is done three times during the execution - first (`tracing sampling`) the trace itself is deciding if it can be just a root span without any details, second time (`Opening span sampling`) before span was opened and third time (`Closing span sampling`) after a span is closing to remove super fast and succesful spans because those probably have no value for you.

### Tracing sampling
In most cases, a detailed trace on each and every request or command execution is not needed. But span is needed to at least know that request took place and had an error inside.
For this, a few things are checked during the trace initialisation. First of all, type of the request is checked. Is it a HTTP request or console command execution.

For the HTTP request HTTP method is checked if it GET or not. If not, the trace is going to be detailed in any case.
If the method was GET, a random number from 0 to 1.0 is generated and compare it against a configured probability. If the generated number less than a configured value - the trace will include spans. If not, only a root span will be present.

Console command sampling works exactly the same, but the configuration value is separate for the more fine-tuning.

### Opening span sampling
When span tried to start check take place if it should be started, by the same algorithm as trace sampling was done. The only difference is that different configuration value is used and the random number is generated on each and every span starting.
Not all spans are equal so different probabilities for different types of spans are used. You can read about criticality of spans below.
If decision was to not sample a span, an empty one will be opened. Empty spans are just a placeholder that are used to build a tree properly. They will appear in the trace in any case.

### Closing span sampling
Super fast spans that have no errors inside of them also can be thrown away from the trace. After the sampled span is closing execution time and status check take place. If span is successful and faster than a configured value (`OTEL_BSP_MIN_SPAN_DURATION_THRESHOLD` or `OTEL_BSP_MIN_CRITICAL_SPAN_DURATION_THRESHOLD`) it will also be omitted and will not appear in the trace.

### Span criticality
Some of the spans are more relevant for users, some of them are not. So for span sampling there are 3 different span criticality: `non critical`, `regular` and `critical` one.
They are using different probability and execution time limits that can be configured separately. (be advises that for `Closing span sampling` `regular` and `non critical` spans as the same span type for now).

#### Critical spans
When something executed that is communicating with other services or change a state of the application, those spans should have bigger probability to be present in the trace. Such spans should be marked as critical.
OOTB there are a few span types that are considered as critical:
- RabbitMQ spans;
- ElasticSearch spans;
- Redis spans;
- Guzzle spans (those are ignored by sampling mechanism as the are required for Distributed Tracing);
- Propel INSERT/DELETE/UPDATE calls;
- Hooks for classes that are configured in `\Spryker\Zed\Opentelemetry\OpentelemetryConfig::getCriticalClassNamePatterns()` method;

They all get a span attribute `is_critical` and use a different probability and execution time values.

#### Non-critical spans
Currently only Propel SELECT calls spans marked as `no_critical` as a lot of them are generated during every request in the system and they can easily overflow a trace with useless information.

#### Regular spans
All other spans are considered as `regular`.

#### Span cricticality configuration
By setting a span attribute `no_critical` and `is_critical`, span can be marked as critical or not.

### Sampling configuration
Values that are used for sampling can be changed. In order to do so, you need to change a few env variables.

| Variable Name                                   | Description                                                       commitomm                                        | Default Value | Allowed range |
|-------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|---------------|---------------|
| `OTEL_BSP_MIN_SPAN_DURATION_THRESHOLD`          | Used in `Closing span sampling` to define a value in ms when spans that execution time is lower to be filtered out | 20            | 0...100000    |
| `OTEL_BSP_MIN_CRITICAL_SPAN_DURATION_THRESHOLD` | Same as a previous one, but used for critical spans only                                                           | 10            | 0...100000    |
| `OTEL_TRACES_SAMPLER_ARG`                       | A probability value that is used to define if WEB GET request trace going to be detailed or not                    | 0.1           | 0...1.0       |
| `OTEL_CLI_TRACE_PROBABILITY`                    | A probability value that is used to define if console command trace going to be detailed or not                    | 0.5           | 0...1.0       |
| `OTEL_TRACES_CRITICAL_SAMPLER_ARG`              | A probability value that is used to define if `critical` span will be sampled or not                               | 0.5           | 0...1.0       |
| `OTEL_TRACES_NON_CRITICAL_SAMPLER_ARG`          | A probability value that is used to define if `non critical` span will be sampled or not                           | 0.1           | 0...1.0       |
| `OTEL_TRACE_PROBABILITY`                        | A probability value that is used to define if `regular` span will be sampled or not                                | 0.3           | 0...1.0       |

Increasing those values will make your traces more detailed, but also can slow down your application as more spans will be sampled and sent to a collector.

### Additional configuration

| Variable Name                        | Description                                                                                                                                                                                                   | Default Value     | Allowed range                                                                                                                                                                                                                 |
|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `OTEL_SERVICE_NAMESPACE`             | Value is used to define a service namespace that is used in resource definition                                                                                                                               | 'spryker'         | any string value                                                                                                                                                                                                              |
| `OTEL_SERVICE_NAME_MAPPING`          | A JSON object that includes mapping from application URL to service name. This mapping is used if no service name was provided via `MonitoringService::setApplicationName()`                                  | '{}'              | valid json with keys as service name and value as  URL pattern                                                                                                                                                                |
| `OTEL_DEFAULT_SERVICE_NAME`          | If no service name is provided and no name was defined in `OTEL_SERVICE_NAME_MAPPING`, this default name will be used instead                                                                                 | 'Default Service' | any valid string                                                                                                                                                                                                              |
| `OTEL_BSP_SCHEDULE_DELAY`            | Defines a delay in ms that will be used to wait before sending batch of spans into the exporter. The bigger the number, the bigger the batch.                                                                 | 1000              | 0...100000000                                                                                                                                                                                                                 |
| `OTEL_BSP_MAX_QUEUE_SIZE`            | Defines a max size of the queue of spans that can be processed in one request                                                                                                                                 | 2048              | at least an amount of spans you want to see                                                                                                                                                                                   |
| `OTEL_BSP_MAX_EXPORT_BATCH_SIZE`     | Defines a size of the batch of spans. After this size is reached, batch will be sent to the exporter.                                                                                                         | 512               | more than 0 and less than `OTEL_BSP_MAX_QUEUE_SIZE`                                                                                                                                                                           |
| `OTEL_SDK_DISABLED`                  | If set to true, non of the traces will be generated or sent to the backend. Default value is `true` as it should be disabled until the collector is up and running                                            | 'true'            | bool or string reperesentation of bool, e.g. 'true' or 'false'                                                                                                                                                                |
| `OTEL_PHP_DISABLED_INSTRUMENTATIONS` | Allows to disable some part of additional instrumentation. E.g. if you don't want to see all Redis spans you can set `spryker_otel_redis` as a value. Or you can list part of instrumentation divided by coma | ''                | 'spryker_otel_redis', 'spryker_otel_elastica', 'spryker_otel_propel', 'spryker_otel_rabbitmq', 'spryker_otel_guzzle' or 'all'. Also you can select a few of instrumentation, e.g. 'spryker_otel_rabbitmq,spryker_otel_propel' |


## Custom attributes

You may want to add some custom data to your traces. E.g. a user id that was logged that time into your system. Or a current store name. Or anything else that can vary from request to request. In order to do so, you can add a custom attribute that will appear in the root span for better visibility.
It's recommended to do so using `MonitoringService::addCustomParameter()` method. By default Spryker provides a few of those attributes already, like a current store name and locale.
If you don't want to use `MonitoringService` for some reason, you may use `\Spryker\Service\Opentelemetry\OpentelemetryService::setCustomParameter` directly. It does exactly the same job, but without necessity to install `Monitoring` module.
All attributes added via those services will be added into the root span on the very end of request execution, so you can call it even after response wes already sent.

## Custom events

If you want to add some custom event to you trace in order to configure some logic into your backend, you can trigger a custom event during the execution. It works pretty much the same as adding custom attributes, so it's pretty easy to use.
The same as for custom attributes you can add those via `\Spryker\Service\Monitoring\MonitoringService::addCustomEvent()` or via `\Spryker\Service\Opentelemetry\OpentelemetryService::addEvent()` if you dont want to install `Monitoring` module.
Event will be wired into the root span.

## Error handling

You are definitely want to track all possible errors during the execution. OOTB OTel integration will catch all exceptions that were thrown during request/command execution and attach those as events into the root span. Those events should also be present in the span of the method that thrown the exception, but only if the hook for this method exists in the first place.
In order to catch those error in any case recommendation is to use `\Spryker\Service\Monitoring\MonitoringService::setError()` or `\Spryker\Service\Opentelemetry\OpentelemetryService::setError()` inside of the Error Handler of your application.
Default Spryker's Error Handler already executes `\Spryker\Service\Monitoring\MonitoringService::setError()`, so if you are using `Monitoring` module and default Error Handler - you are covered. But if you don't, please adjust your error handler accordingly.
This will add a error event into the root span and will change its status to the `error` one. Please check this part during integration of OTel into your system.

## Changing a service name

Service name allows you to filter traces by the source. You may want to check only Yves traces or mb just to check only Glue requests, but you backend can show you a bunch of CLI commands from your Scheduler.

You can define a service name via `\Spryker\Service\Monitoring\MonitoringService::setApplicationName()` or `\Spryker\Service\Opentelemetry\OpentelemetryService::setResourceName()`.

All `MonitoringService` methods will trigger service name changing, so if e.g. `\Spryker\Service\Monitoring\MonitoringService::setError()` was called, service name will be changed too.

By default it looks like `APPLICATION-REGION_OR_STORE(application.env)`, where `APPLICATION` is a name of your application (ZED, YVES, GLUE, etc.), `REGION_OR_STORE` is a current store or region name that depends if your application works in Dynamic Store mode or not, and `application.env` is an env name from your deploy file. You can change any of those value via `MonitoringService` or change the name completely via `OpentelemetryService`.
If no service name was provided by services, OTel integration will try to resolve a service name for you.
First of all `OTEL_SERVICE_NAME_MAPPING` value will be fetched and will try to find a proper service name based on the URL or CLI binary file name.
If no value was provided or nothing from it was suitable or us - the default service name from `OTEL_DEFAULT_SERVICE_NAME` env value will be used.

## Changing a trace name

Trace name (or in our case a root span name) should show you what request or command was executed. Default implementation includes a HTTP method name with a route name for the WEB requests and command name for a command execution.
But it can be also changed during the execution. OOTB Spryker will change a WEB requests trace name in order to reflect a route name of the request. But if you don't like it or don't use a `Monitoring` module, you can define it via `\Spryker\Service\Opentelemetry\OpentelemetryService::setRootSpanName()` or `\Spryker\Service\Monitoring\MonitoringService::setTransactionName()`.

## Recommendations

Due to the fact that PHP code is used to instrument codebase, you should consider performance. Tracing is an expensive operation and can slow down your application. Here are some recommendations to avoid performance issues:

Please minimise amount of generated spans per request. OTel documentation recommends to have no more than 1000 of them. So you can skip some spans via configuration that are not relevant to you. Don't be afraid, errors will be processed even if the method was not instrumented because Error Event will be attached to the root span.

Use sampling to not get a full trace every time. Please check configuration section for the reference.

Skip some traces. You may not want to get a full trace for all of your transactions. You can define a probability of detailed trace overview by setting a probability via `OTEL_TRACE_PROBABILITY` env variable. Be advised that Trace still will be processed and root span will be there for you. Also requests that are changing something in your application (POST, DELETE, PUT, PATCH) considered as critical and will be processed anyway.
